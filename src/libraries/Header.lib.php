<?php

/**************************************************************************************************
*
* "Header" file included at the start of each controller file. The goal is to provide common 
* static classes for basic operations (e.g. read/write in the DB) that are used in most scripts.
*
* This file also deals with a user's connection to the website. It will init several parameters 
* (as static or const variables of some classes) which will be used by other parts of the code to 
* detect the membership of the user, his or her permissions, and react accordingly (e.g. forbid 
* the edition of another user's post).
*
**************************************************************************************************/

/*
* Global variable used to measure the time taken to execute a full script and render a page. It's 
* only handled in practice in this file (see wrap()) and in the Footer.inc.php file.
*/

$overallStart = microtime(true);

/*
* Determines automatically the absolute path to the base folder of the website (i.e., equivalent 
* to the www/ or httpdocs/ folder).
*/

$autoWWW = realpath($_SERVER['DOCUMENT_ROOT']).'/';

/*
* Next global fetches some configuration values used to log to the DB. It's technically a global 
* but only this file uses it in practice.
*/

$configValues = include($autoWWW.'config/Config.inc.php');

/*
* Determines as well as the base URL. Base URL is forced to be prefixed with "www." to avoid 
* logging in issues (e.g. if user first connects to the website without the "www."). Note how 
* the protocol (i.e., HTTP or HTTPS) is part of the configuration values.
*/

$autoHTTP = $_SERVER['SERVER_NAME']; // Some insight: https://stackoverflow.com/questions/2297403/what-is-the-difference-between-http-host-and-server-name-in-php
if(substr($autoHTTP, 0, 4) !== 'www.')
   $autoHTTP = 'www.'.$autoHTTP;
$autoHTTP = $configValues['protocol'].'://'.$autoHTTP.'/';

/*
* ========
* Database
* ========
*
* This static class is used to dialog with the database. Not only it helps to tell in the code 
* when the Database is accessed (thanks to Database:: prefix), but it also acts as a security 
* bottleneck; i.e., if there's something wrong with the way SQL queries are parsed and executed, 
* one should normally only edit this particular class and nothing else.
*
* Note that the "read" and "write" methods are in name only. Their body can virtually execute 
* anything. However, the Database interface is designed to provide the right results (depending on 
* the nature of the query) as return values, as well as explicitely tell in the calling code what 
* kind of operation is being performed (i.e., reading or editing the database).
*/

class Database
{
   private static $pdo = NULL;
   
   /*
   * Initializes the connection to the DB. No parameter is required; log in details are hard-coded 
   * in the method, which should therefore be edited when moving this file to another server.
   */
   
   public static function init()
   {
      global $configValues;
      
      try
      {
         $pdo_options[PDO::ATTR_ERRMODE] = PDO::ERRMODE_EXCEPTION;
         
         $DSN = 'mysql:host='.$configValues['mysql_host'].';';
         if($configValues['mysql_port'] != -1)
            $DSN .= 'port='.strval($configValues['mysql_port']).';';
         $DSN .= 'dbname='.$configValues['mysql_db_name'];
         
         self::$pdo = new PDO($DSN, $configValues['mysql_login'], $configValues['mysql_pwd']);
         self::$pdo->exec("SET CHARACTER SET utf8");
      }
      catch(Exception $e)
      {
         // Stops if the connection could not be established.
         die('Could not connect to the database ('.$e->getMessage().')');
      }
   }
   
   /*
   * hardWrite() executes $query, assumed to perform a write operation in the database (insertion 
   * or update). Such $query does not need to be parsed (hence the "hard").
   *
   * @param string $query  The query to execute
   * @param bool $nbRows   A boolean that can be used to change the return value of this method 
   *                       into the number of rows affected by the query (optional)
   * @return mixed         Number of affected rows if $returnNbRows is true, otherwise NULL in 
   *                       case of success; the error generated by PDO is returned otherwise
   */ 
   
   public static function hardWrite($query, $nbRows = false)
   {
      $queryObject = self::$pdo->query($query);
      
      $error = self::$pdo->errorInfo();
      if($error[1] != NULL)
         return $error;
         
      $returnValue = NULL;
      if($nbRows)
        $returnValue = $queryObject->rowCount();
      $queryObject->closeCursor();
      
      return $returnValue;
   }
   
   /*
   * hardRead() is the equivalent of hardWrite() for reading in the database.
   *
   * @param string $query    The query to execute
   * @param bool $singleRes  A boolean that can be used to return a simple array if the query is 
   *                         guaranteed to return a single row; a 2D array with several rows is 
   *                         returned otherwise (optional)
   * @return mixed           The row(s) matching the query as a 2D or linear array if $singleRes 
   *                         is true in case of success; otherwise, the PDO error is returned
   */
   
   public static function hardRead($query, $singleRes = false)
   {
      $queryObject = self::$pdo->query($query);
      
      $error = self::$pdo->errorInfo();
      if($error[1] != NULL)
         return $error;
      
      if($singleRes)
         $result = $queryObject->fetch(PDO::FETCH_ASSOC);
      else
         $result = $queryObject->fetchAll(PDO::FETCH_ASSOC);
      $queryObject->closeCursor();
      return $result;
   }
   
   /*
   * secureWrite() executes $query, assumed to perform a write operation in the database. It 
   * is essentially a proxy for PDO prepared query mechanism for queries that modify the content 
   * of the database.
   *
   * @param string $query  The query to execute (args are either question marks or identifiers)
   * @param mixed $arg[]   The inputs to parse in the query
   * @param bool $nbRows   A boolean that can be used to change the return value of this method 
   *                       into the number of rows affected by the query, just like hardWrite()
   * @return mixed         Number of affected rows if $returnNbRows is true, otherwise NULL in 
   *                       case of success; if something goes wrong, the PDO error is returned
   */
   
   public static function secureWrite($query, $arg, $nbRows = false)
   {
      $queryObject = self::$pdo->prepare($query);
      
      $error = self::$pdo->errorInfo();
      if($error[1] != NULL)
         return $error;
      
      $queryObject->execute($arg);
      
      $error = $queryObject->errorInfo();
      if($error[1] != NULL)
         return $error;
      
      $returnValue = NULL;
      if($nbRows)
        $returnValue = $queryObject->rowCount();
      
      $queryObject->closeCursor();
      return $returnValue;
   }
   
   /*
   * secureRead() is the equivalent of secureWrite() for reading in the database.
   *
   * @param string $query    The query to execute (args are either question marks or identifiers)
   * @param mixed $arg[]     The inputs to parse in the query
   * @param bool $singleRes  A boolean that can be used to return a simple array if the query is 
   *                         guaranteed to return a single row (2D array is returned otherwise)
   * @return mixed           The row(s) matching the query as a 2D or linear array if $singleRes 
   *                         is true; the PDO error is returned in case of problem
   */
   
   public static function secureRead($query, $arg, $singleRes = false)
   {
      $queryObject = self::$pdo->prepare($query);
      
      $error = self::$pdo->errorInfo();
      if($error[1] != NULL)
         return $error;
      
      $queryObject->execute($arg);
      
      $error = $queryObject->errorInfo();
      if($error[1] != NULL)
         return $error;
      
      if($singleRes)
         $result = $queryObject->fetch(PDO::FETCH_ASSOC);
      else
         $result = $queryObject->fetchAll(PDO::FETCH_ASSOC);
      $queryObject->closeCursor();
      return $result;
   }
   
   /*
   * newId() returns the ID of the last row inserted in the database with PDO.
   *
   * @return number  The ID of the last inserted row (self::$pdo->lastInsertId())
   */
   
   public static function newId()
   {
      return self::$pdo->lastInsertId();
   }
   
   /*
   * beginTransaction(), commit() and rollback() are just aliases for the PDO methods of the same 
   * name. The purpose is to avoid using "global $pdo;" in functions/methods involving 
   * transactions and to explicitely reference this static class (for the sake of clarity).
   */
   
   public static function beginTransaction() { self::$pdo->beginTransaction(); }
   public static function commit() { self::$pdo->commit(); }
   public static function rollback() { self::$pdo->rollback(); }
   
   /*
   * Method to prepare a query that should be executed several times. The query object is returned 
   * to ensure the $pdo variable stays encapsulated and unreachable from outside. This method is 
   * used very rarely for now.
   *
   * @param string $query  The SQL query to prepare
   * @return PDOStatement  The PDO query object
   */
   
   public static function prepare($query)
   {
      return self::$pdo->prepare($query);
   }
}

Database::init();

/*
* ==========
* LoggedUser
* ==========
*
* This class handles the currently logged user, if logged in, in order to check if the associated 
* account exists (and if the hashed password matches), check if the user has specific functions in 
* the website and handle his/her abilities and preferences. For the class that can be used to 
* create and manage users in general, see User class in model/.
*/

session_start();

class LoggedUser
{
   public static $data = NULL; // Main array, contains pseudonym(s), used pseudonym and abilities
   public static $fullData = NULL; // Contains the full row extracted from the DB that matches this user (if logged)
   public static $messages = NULL; // Unread messages (N.B.: to change into more general notifications later)
   
   // N.B.: when the current user isn't logged in, all these fields remain to "NULL".
   
   /*
   * Private static method that forces log out by destroying $_SESSION variables as well as 
   * cookies (if they exist).
   */
   
   private static function forceLogOut()
   {
      $_SESSION['pseudonym'] = '';
      $_SESSION['password'] = '';
      if(!empty($_COOKIE['pseudonym']) && !empty($_COOKIE['password']))
      {
         $expire = $timestampNow - 24 * 60 * 60;
         setcookie('pseudonym', '', $expire);
         setcookie('password', '', $expire);
      }
   }
   
   /*
   * Private static method that performs the log in procedure. Pseudonym and password are 
   * parameters because they are found in $_SESSION variables, either in cookies.
   *
   * @param string $pseudo  Pseudonym of the user to log in
   * @param string $pwd     Hashed password (SHA-1)
   * @return bool           True if the user was properly authenticated
   */
   
   private static function logInProcedure($pseudo, $pwd)
   {
      $sql = "SELECT * FROM users WHERE pseudo=? LIMIT 1";
      $arg = array(Utils::secure($pseudo));
      self::$fullData = Database::secureRead($sql, $arg, true);
      
      $timestampBan = Utils::toTimestamp(self::$fullData['last_ban_expiration']);
      $timestampNow = Utils::SQLServerTime();
      
      if(count(self::$fullData) > 3 && self::$fullData != NULL && self::$fullData['confirmation'] === 'DONE')
      {
         if($pwd === self::$fullData['password'] && $timestampNow > $timestampBan)
         {
            // Prepares the main array
            self::$data = array('pseudo' => $pseudo,
            'function_pseudo' => self::$fullData['function_pseudo'],
            'used_pseudo' => $pseudo,
            'new_messages' => 0);
            
            // Updates last connection date
            $datetimeNow = Utils::toDatetime($timestampNow);
            $res = Database::secureWrite("UPDATE users SET last_connection=? WHERE pseudo=?", 
                                         array($datetimeNow, self::$data['pseudo']));
            
            // Updates the related array cell as well
            if($res == NULL)
               self::$fullData['last_connection'] = $datetimeNow;
            
            return true;
         }
         
         self::forceLogOut();
         return false;
      }
      
      self::forceLogOut();
      return false;
   }
   
   /*
   * Conducts the full log in operation, i.e., it first tries the log in with $_SESSION variables 
   * (when available) then with cookies (=> long-term log in; again, only if available). If 
   * successful, a few additional operations are carried out to check the abilities of this user 
   * and get his/her amount of new messages (notifications in the future).
   */
   
   public static function init()
   {
      $res = false;
      
      if(!empty($_SESSION['pseudonym']) && !empty($_SESSION['password']))
      {
         $res = self::logInProcedure($_SESSION['pseudonym'], $_SESSION['password']);
      }
      else if(!empty($_COOKIE['pseudonym']) && !empty($_COOKIE['password']))
      {
         $res = self::logInProcedure($_COOKIE['pseudonym'], $_COOKIE['password']);
         if($res)
         {
            $_SESSION['pseudonym'] = $_COOKIE['pseudonym'];
            $_SESSION['password'] = $_COOKIE['password'];
         }
      }
      
      if(!$res)
         return;
      
      $defaultAbilities = array('function_name' => '', 
      'can_create_topics' => 'no', 
      'can_upload' => 'no', 
      'can_edit_all_posts' => 'no', 
      'can_edit_games' => 'no', 
      'can_edit_users' => 'no', 
      'can_mark' => 'no', 
      'can_lock' => 'no', 
      'can_delete' => 'no', 
      'can_ban' => 'no', 
      'can_invite' => 'no');

      if(strlen(self::$data['function_pseudo']) > 0)
      {
         $sql = "SELECT functions.* FROM map_functions NATURAL JOIN functions WHERE function_pseudo=?";
         $secondAccount = Database::secureRead($sql, array(self::$data['function_pseudo']), true);
         
         // Using abilities of the function account
         if($secondAccount != NULL && count($secondAccount) > 3 && isset($_SESSION['function_pseudo']) && 
            $_SESSION['function_pseudo'] === sha1(self::$data['function_pseudo']))
         {
            self::$data = array_merge(self::$data, $secondAccount);
            self::$data['used_pseudo'] = self::$data['function_pseudo'];
         }
         // Regular account (with or without advanced features) permissions otherwise
         else
         {
            $defaultAbilities['function_name'] = $secondAccount['function_name'];
            if(self::$fullData['advanced_features'] === 'yes')
            {
               $defaultAbilities['can_create_topics'] = 'yes';
               $defaultAbilities['can_upload'] = 'yes';
               $defaultAbilities['can_invite'] = 'yes';
            }
            
            self::$data = array_merge(self::$data, $defaultAbilities);
         }
      }
      // Idem, with no function name at all
      else
      {
         if(self::$fullData['advanced_features'] === 'yes')
         {
            $defaultAbilities['can_create_topics'] = 'yes';
            $defaultAbilities['can_upload'] = 'yes';
            $defaultAbilities['can_invite'] = 'yes';
         }
         
         self::$data = array_merge(self::$data, $defaultAbilities);
      }
      
      // Counts the amount of unread new messages.
      $sql = "SELECT pings.id_ping, pings.ping_type, pings.title, pings.emitter, pings.receiver 
      FROM map_pings 
      NATURAL JOIN pings
      WHERE map_pings.pseudo=? 
      AND map_pings.viewed='no'
      ORDER BY map_pings.last_update DESC, map_pings.id_ping DESC";
      
      self::$messages = Database::secureRead($sql, array(self::$data['pseudo']));
      if(!(count(self::$messages) > 0 && !is_array(self::$messages[0]) && count(self::$messages) == 3))
         self::$data['new_pings'] = count(self::$messages);
      else
         self::$data['new_pings'] = -1; // Alert other parts of the code that there's a problem
   }
   
   // Static method to quickly check the current user is logged in (true) or not (false).
   
   public static function isLoggedIn()
   {
      return self::$data != NULL && is_array(self::$data);
   }
   
   /*
   * Returns a string describing the rank (or function, if being used) of the current user.
   *
   * @return string  The "rank" of this user
   */
   
   public static function rank()
   {
      if(self::isLoggedIn())
      {
         if(self::$data['used_pseudo'] == self::$data['function_pseudo'])
            return self::$data['function_name'];
         else
            return 'regular user';
      }
      return 'anonymous';
   }
}

LoggedUser::init();

/*
* ===========
* PathHandler
* ===========
*
* The purpose of this static class is to gather everything needed to properly handle paths on the 
* website. In particular, it provides WWW_PATH, used to reach files on the server via absolute 
* paths, and HTTP_PATH, the client side equivalent (i.e., to get full URLs). JS_EXTENSION also 
* provides the typical extensions of JS files (usually .js or .min.js), which is given by the main 
* configuration file of the website. All three of them are private static elements but can be 
* accessed with public methods with the same names (as a way to compensate for the impossibility 
* to use constants in this context). PathHandler also provides a few utilities as well as methods 
* that should be used to rewrite URLs (e.g., instead of - only - using Article.php?id_article=1, 
* one can use the URL /articles/1/My-article-title-and-subtitle which is better for referencing).
*/

class PathHandler
{
   private static $WWW_PATH;
   private static $HTTP_PATH;
   private static $JS_EXTENSION;
   
   /*
   * Inits the public static variables of the class. Such variables used to be constants; in order 
   * to ease configuration of the website, they were turned into private static elements to allow 
   * setting them through the code while preventing their edition from outside. They are then 
   * accessed via (public) static methods. Indeed, it's forbidden by the language to set constants 
   * via variables (details here: https://www.php.net/manual/en/language.oop5.static.php ). This 
   * means that in practice, PathHandler "constants" are used as if they were, but with additional 
   * parentheses.
   */
   
   public static function init()
   {
      global $autoWWW;
      global $autoHTTP;
      global $configValues;
      
      self::$WWW_PATH = $autoWWW;
      self::$HTTP_PATH = $autoHTTP;
      self::$JS_EXTENSION = $configValues['paths_js_extension'];
   }
   
   public static function WWW_PATH() { return self::$WWW_PATH; }
   public static function HTTP_PATH() { return self::$HTTP_PATH; }
   public static function JS_EXTENSION() { return self::$JS_EXTENSION; }
   
   /*
   * getAvatar() gets the absolute path to one user's avatar on the basis of its pseudonym.
   *
   * @param string $pseudo  The user's pseudonym
   * @return string         The absolute path to that user's avatar, or to a default one
   */

   public static function getAvatar($pseudo)
   {
      if(WebpageHandler::$miscParams['message_size'] === 'medium')
      {
         $avatarPath = self::$WWW_PATH.'avatars/'.$pseudo.'-medium.jpg';
         if(file_exists($avatarPath) == true)
            return self::$HTTP_PATH.'avatars/'.$pseudo.'-medium.jpg';
         return self::$HTTP_PATH.'defaultavatar-medium.jpg';
      }
      
      $avatarPath = self::$WWW_PATH.'avatars/'.$pseudo.'.jpg';
      if(file_exists($avatarPath) == true)
         return self::$HTTP_PATH.'avatars/'.$pseudo.'.jpg';
      return self::$HTTP_PATH.'defaultavatar.jpg';
   }
   
   /*
   * getAvatarSmall() gets the absolute path to the smallest version of one user's avatar.
   *
   * @param string $pseudo  The user's pseudonym
   * @return string         The absolute path to that user's avatar, small size
   */
   
   public static function getAvatarSmall($pseudo)
   {
      $avatarPath = self::$WWW_PATH.'avatars/'.$pseudo.'-small.jpg';
      if(file_exists($avatarPath) == true)
         return self::$HTTP_PATH.'avatars/'.$pseudo.'-small.jpg';
      return self::$HTTP_PATH.'defaultavatar-small.jpg';
   }
   
   /*
   * getAvatarSmall() gets the absolute path to the medium version of one user's avatar.
   *
   * @param string $pseudo  The user's pseudonym
   * @return string         The absolute path to that user's avatar, medium size
   */
   
   public static function getAvatarMedium($pseudo)
   {
      $avatarPath = self::$WWW_PATH.'avatars/'.$pseudo.'-medium.jpg';
      if(file_exists($avatarPath) == true)
         return self::$HTTP_PATH.'avatars/'.$pseudo.'-medium.jpg';
      return self::$HTTP_PATH.'defaultavatar-medium.jpg';
   }
   
   /*
   * getThumbnail() returns the absolute path of the thumbnail of a topic on the basis of its ID
   * or name (because a topic could use a thumbnail from a default library, found with a precise 
   * name). A default thumbnail is returned if no file could be found at the path.
   *
   * @param string $name     The name of the thumbnail
   * @param string $idTopic  The ID of the topic (helps to find the custom thumbnail if $name is
   *                         equal to CUSTOM)
   * @return string          The absolute path to a thumbnail for that topic
   */
   
   public static function getTopicThumbnail($name, $idTopic)
   {
      if($name === 'CUSTOM')
         $suffix = 'upload/topics/'.$idTopic.'/thumbnail.jpg';
      else
         $suffix = $name;
      
      $thumbnailPath = self::$WWW_PATH.$suffix;
      if(file_exists($thumbnailPath) == true)
         return self::$HTTP_PATH.$suffix;
      return self::$HTTP_PATH.'defaultthumbnail.jpg';
   }
   
   /*
   * General method to format a string to fit in a URL, i.e. the formatted string will only 
   * contain characters in class a-zA-Z0-9 and -.
   *
   * @param string $input  The string to format
   * @return string        The formatted string
   */
   
   public static function formatForURL($input)
   {
      // Replace accents
      $accents = array('Š'=>'S', 'š'=>'s', 'Ž'=>'Z', 'ž'=>'z', 'À'=>'A', 'Á'=>'A', 'Â'=>'A', 
      'Ã'=>'A', 'Ä'=>'A', 'Å'=>'A', 'Æ'=>'A', 'Ç'=>'C', 'È'=>'E', 'É'=>'E', 'Ê'=>'E', 'Ë'=>'E', 
      'Ì'=>'I', 'Í'=>'I', 'Î'=>'I', 'Ï'=>'I', 'Ñ'=>'N', 'Ò'=>'O', 'Ó'=>'O', 'Ô'=>'O', 'Õ'=>'O', 
      'Ö'=>'O', 'Ø'=>'O', 'Ù'=>'U', 'Ú'=>'U', 'Û'=>'U', 'Ü'=>'U', 'Ý'=>'Y', 'Þ'=>'B', 'ß'=>'Ss', 
      'à'=>'a', 'á'=>'a', 'â'=>'a', 'ã'=>'a', 'ä'=>'a', 'å'=>'a', 'æ'=>'a', 'ç'=>'c', 'è'=>'e', 
      'é'=>'e', 'ê'=>'e', 'ë'=>'e', 'ì'=>'i', 'í'=>'i', 'î'=>'i', 'ï'=>'i', 'ð'=>'o', 'ñ'=>'n', 
      'ò'=>'o', 'ó'=>'o', 'ô'=>'o', 'õ'=>'o', 'ö'=>'o', 'ø'=>'o', 'ù'=>'u', 'ú'=>'u', 'û'=>'u', 
      'ý'=>'y', 'þ'=>'b', 'ÿ'=>'y');
      $output = strtr($input, $accents);
      
      // Replace spaces and special characters
      $output = str_replace(" ", "-", $output);
      $output = preg_replace("([^a-zA-Z0-9-])", "", $output);
      
      // If it ends with -, removes them
      while(substr($output, -1) == '-')
         $output = substr($output, 0, strlen($output) - 1);
      
      return $output;
   }
   
   /*
   * General method to format a string to fit as a filename, i.e. the formatted string will only 
   * contain characters in class a-zA-Z0-9, _ and -.
   *
   * @param string $input  The string to format
   * @return string        The formatted string
   */
   
   public static function formatForFilesystem($input)
   {
      // Replace accents
      $accents = array('Š'=>'S', 'š'=>'s', 'Ž'=>'Z', 'ž'=>'z', 'À'=>'A', 'Á'=>'A', 'Â'=>'A', 
      'Ã'=>'A', 'Ä'=>'A', 'Å'=>'A', 'Æ'=>'A', 'Ç'=>'C', 'È'=>'E', 'É'=>'E', 'Ê'=>'E', 'Ë'=>'E', 
      'Ì'=>'I', 'Í'=>'I', 'Î'=>'I', 'Ï'=>'I', 'Ñ'=>'N', 'Ò'=>'O', 'Ó'=>'O', 'Ô'=>'O', 'Õ'=>'O', 
      'Ö'=>'O', 'Ø'=>'O', 'Ù'=>'U', 'Ú'=>'U', 'Û'=>'U', 'Ü'=>'U', 'Ý'=>'Y', 'Þ'=>'B', 'ß'=>'Ss', 
      'à'=>'a', 'á'=>'a', 'â'=>'a', 'ã'=>'a', 'ä'=>'a', 'å'=>'a', 'æ'=>'a', 'ç'=>'c', 'è'=>'e', 
      'é'=>'e', 'ê'=>'e', 'ë'=>'e', 'ì'=>'i', 'í'=>'i', 'î'=>'i', 'ï'=>'i', 'ð'=>'o', 'ñ'=>'n', 
      'ò'=>'o', 'ó'=>'o', 'ô'=>'o', 'õ'=>'o', 'ö'=>'o', 'ø'=>'o', 'ù'=>'u', 'ú'=>'u', 'û'=>'u', 
      'ý'=>'y', 'þ'=>'b', 'ÿ'=>'y');
      $output = strtr($input, $accents);
      
      // Replace spaces and special characters
      $output = str_replace(" ", "-", $output);
      $output = preg_replace("([^a-zA-Z0-9-])", "", $output);
      
      // If it ends with -, removes them
      while(substr($output, -1) == '-')
         $output = substr($output, 0, strlen($output) - 1);
      
      return $output;
   }
   
   /*
   * The rest of the classes consists of a "[something]URL()" static methods. The principle is 
   * always the same: the method takes the array which matches the content for which the URL must 
   * be generated, possibly with additional variables to denote a specific section or page. The 
   * output is always a string (the URL). Having such methods is a way to have a bottleneck to 
   * handle URLs for content, e.g. if the URL has to be updated because of a new URL rewriting 
   * policy.
   */
   
   // URLs related to topics (and related sections)
   
   public static function topicURL($topic, $page = '')
   {
      $URL = './Topic.php?id_topic='.$topic['id_topic'];
      if($page !== '' && intval($page) != 1)
         $URL .= '&page='.$page;
      return $URL;
   }
   
   public static function uploadsURL($topic, $page = '')
   {
      $URL = './Uploads.php?id_topic='.$topic['id_topic'];
      if($page !== '' && intval($page) != 1)
         $URL .= '&page='.$page;
      return $URL;
   }
   
   public static function popularPostsURL($topic, $page = '')
   {
      $URL = './PopularPosts.php?id_topic='.$topic['id_topic'];
      if($page !== '' && intval($page) != 1)
         $URL .= '&page='.$page;
      return $URL;
   }

   public static function unpopularPostsURL($topic, $page = '')
   {
      $URL = './PopularPosts.php?section=unpopular&id_topic='.$topic['id_topic'];
      if($page !== '' && intval($page) != 1)
         $URL .= '&page='.$page;
      return $URL;
   }
   
   // URLs for content
   
   public static function gameURL($game, $section = '', $page = '')
   {
      $URL = './Game.php?game='.urlencode($game['tag']);
      if(in_array($section, array('articles', 'trivia', 'lists', 'topics')))
      {
         $URL .= '&section='.$section;
         if($page !== '' && intval($page) != 1)
            $URL .= '&page='.$page;
      }
      return $URL;
   }
   
   public static function articleURL($article, $segment = '')
   {
      $titleFormatted = self::formatForURL($article['title'].' '.$article['subtitle']);
      $URL = 'articles/'.$article['id_article'].'/'.$titleFormatted.'/';
      if($segment !== '' && intval($segment) != 1)
         $URL .= $segment.'/';
      
      return self::$HTTP_PATH.$URL;
   }
   
   public static function triviaURL($trivia)
   {
      $URL = 'trivia/'.$trivia['id_commentable'].'/'.self::formatForURL($trivia['game']).'/';
      $URL .= PathHandler::formatForURL($trivia['title']).'/';
      
      return self::$HTTP_PATH.$URL;
   }
   
   public static function listURL($list)
   {
      $URL = 'lists/'.$list['id_commentable'].'/'.self::formatForURL($list['title']).'/';
      
      return self::$HTTP_PATH.$URL;
   }
   
   // Miscellaneous
   
   public static function userURL($pseudo)
   {
      return './User.php?user='.urlencode($pseudo);
   }
}

PathHandler::init();

/*
* ==============
* WebpageHandler
* ==============
*
* This static class handles a variety of variables tied to the display (HTML- and CSS-wise) or 
* functionality of the website (w.r.t. JavaScript). Most notably, it gathers two arrays which 
* lists the CSS and JS files that should be used when outputting the final page (which are put to 
* use in Header.inc.php, notably), as well as miscellaneous variables to handle some URLs and 
* containing div's. Finally, it also maintains a large array nicknamed "miscParams" that gathers a 
* variety of parameters which influence both the display (e.g., amount of messages displayed per 
* page) and the QOL (e.g., activation of auto-preview automically).
*/

class WebpageHandler
{
   public static $CSSFiles; // CSS files to use
   public static $JSFiles; // JS files to use
   public static $redirections; // Array of 2 bools to handle redirection uppon logging in/out
   public static $URLRewriting; // Bool set to true if the URL of this page has been rewritten for better referencing
   public static $container; // Array of 2 strings containing start and end tag(s) of div's encapsulating the parsed template to display
   public static $miscParams; // See above
   
   public static function init()
   {
      self::$CSSFiles = array();
      self::$JSFiles = array();
      self::$redirections = array('log_in' => false, 'log_out' => true);
      self::$URLRewriting = false;
      
      // Default encapsulation
      self::$container = array(
      'start' => '<div id="content">'."\n".'<div class="wallOfText">'."\n", 
      'end' => '</div>'."\n".'</div>'."\n");
      
      // Default parameters
      self::$miscParams = array(
      'webdesign_variant' => 'default', // (November 2021) Selects a specific variant of the logo while displaying an article (in function of its type)
      'posts_per_page' => 10, // Amount of messages per page in a topic (normally 20)
      'topics_per_page' => 30, // Amount of topics per page in a list of topics
      'articles_per_page' => 30, // Same for the articles
      'emoticons_per_page' => 30, // Amount of emoticons per page on the "My emoticons" page 
      'pins_per_page' => 50, // Amount of pins per page on the "My pins" page
      'message_size' => 'default', // "Size" of message at display (large or medium; change size of avatars, font, icons)
      'video_default_display' => 'thumbnail', // Whether videos are embedded at load time or not
      'video_thumbnail_style' => 'hq', // Size of the thumbnail for videos (HQ, i.e. 480x360, by default)
      'default_nav_mode' => 'classic', // Navigation mode (topics, pings) by default
      'auto_preview' => 'no', // Activation by default of automatic/quick preview
      'auto_refresh' => 'no', // Activation by default of auto refresh
      'consecutive_posts_delay' => 15, // Minimum delay in seconds between two consecutive posts
      'consecutive_anon_posts_delay' => 120, // Minimum delay in seconds between two consecutive posts (anonymous posting)
      'consecutive_topics_delay' => 1800, // Same but for consecutive topics created by the same user (except if admin)
      'consecutive_pings_delay' => 180, // Same but for consecutive "pings" created by the same user (except if admin)
      'meta_title' => '', // Meta-tag: title of the content
      'meta_description' => '', // Meta-tag: description of the content
      'meta_image' => '', // Meta-tag: image/thumbnail
      'meta_url' => '' // Meta-tag: URL
      );
   }
   
   public static function addCSS($fileName)
   {
      array_push(self::$CSSFiles, $fileName);
   }
   
   public static function addJS($fileName)
   {
      array_push(self::$JSFiles, $fileName);
   }
   
   public static function redirectionAtLoggingIn()
   {
      self::$redirections['log_in'] = true;
   }
   
   public static function noRedirectionAtLoggingOut()
   {
      self::$redirections['log_out'] = false;
   }
   
   public static function changeContainer($divName)
   {
      self::$container['start'] = '<div id="'.$divName.'">'."\n";
      self::$container['end'] = '</div>'."\n";
   }
   
   public static function noContainer()
   {
      self::$container['start'] = '';
      self::$container['end'] = '';
   }
   
   public static function usingURLRewriting()
   {
      self::$URLRewriting = true;
   }
   
   // Resets the display for some specific scripts (e.g., success pages)
   
   public static function resetDisplay()
   {
      // Gets empty lists for JS/CSS files
      self::$CSSFiles = array();
      self::$JSFiles = array();
      
      // Uses again default encapsulation
      self::$container = array(
      'start' => '<div id="content">'."\n".'<div class="wallOfText">'."\n", 
      'end' => '</div>'."\n".'</div>'."\n");
   }
   
   /*
   * Receives a HTML code and encapsulates it in a single div (default name: "singleBlock").
   *
   * @param string $html  The HTML code to encapsulated
   * @param string $name  The name of the block; "singleBlock" by default
   * @return string       The encapsulated HTML code
   */
   
   public static function wrapInBlock($html, $blockName = 'singleBlock')
   {
      $newHtml = '      <div class="'.$blockName.'">'."\n";
      $newHtml .= $html;
      $newHtml .= '      </div>'."\n";

      return $newHtml;
   }

   /*
   * Receives a HTML code, a page title and a optional set of "boxes" (HTML code that can be 
   * used to integrate dialog boxes that can be interacted with through JavaScript), then displays 
   * the whole and exits.
   *
   * @param string $html       The HTML code to display (page itself; not the whole design)
   * @param string $pageTitle  The title of the HTML page (displayed in the browser's tab)
   * @param string $dialogs    Concatenated dialog boxes or single dialog box written in HTML and
   *                           made interactible through JavaScript (optional)
   */
   
   public static function wrap($html, $pageTitle, $dialogs = '')
   {
      global $overallStart;
      
      $overallEnd = microtime(true);
      $finalHTML = $html;
      if(WebpageHandler::$URLRewriting)
         $finalHTML = str_replace('="./', '="'.PathHandler::HTTP_PATH(), $finalHTML);
      
      require './view/Header.inc.php';
      echo $finalHTML;
      require './view/Footer.inc.php';
      exit();
   }
}

WebpageHandler::init();

/*
* ====================
* Personal preferences
* ====================
*/

if(LoggedUser::isLoggedIn())
{
   if(LoggedUser::$fullData['using_preferences'] === 'yes')
   {
      WebpageHandler::$miscParams['posts_per_page'] = LoggedUser::$fullData['pref_posts_per_page'];
      WebpageHandler::$miscParams['message_size'] = LoggedUser::$fullData['pref_message_size'];
      WebpageHandler::$miscParams['video_default_display'] = LoggedUser::$fullData['pref_video_default_display'];
      WebpageHandler::$miscParams['video_thumbnail_style'] = LoggedUser::$fullData['pref_video_thumbnail_style'];
      WebpageHandler::$miscParams['default_nav_mode'] = LoggedUser::$fullData['pref_default_nav_mode'];
      WebpageHandler::$miscParams['auto_preview'] = LoggedUser::$fullData['pref_auto_preview'];
      WebpageHandler::$miscParams['auto_refresh'] = LoggedUser::$fullData['pref_auto_refresh'];
   }
}

/*
* =====
* Utils
* =====
*
* This static class gathers a bunch of utility methods which are used in various scripts. In 
* particular, it gathers every method tied to handling time (as DATETIME or as a timestamp).
*/

class Utils
{
   private static $bufferedTime = 0;
   
   const UPLOAD_OPTIONS = array(
   'bufferLimit' => 10, // Max amount of uploads per message (in the user's buffer)
   'extensions' => array('jpeg', 'jpg', 'gif', 'png', 'mp4', 'webm'), // Available extensions
   'miniExtensions' => array('jpeg', 'jpg', 'gif', 'png'), // Extensions with custom miniatures
   'displayPolicies' => array('default', 'spoiler', 'nsfw', 'noshow', 'noshownsfw', 'noshowspoiler') // Display policies (besides typical display below message)
   );
   
   /*
   * Shortens the title of some content if that title is longer than 45 characters. The method 
   * also incorporates a simple heuristic: if the "-" character is present, then it keeps 
   * everything after that character and shortens what comes before.
   *
   * @param string $title  Title to shorten
   * @return string        Shortened title, or the same string if no need to shorten the title
   */
   
   public static function shortenTitle($title)
   {
      if(strlen($title) < 40)
         return $title;
         
      $shortened = '';
      if(strpos($title, ' - ') !== FALSE)
      {
         $exploded1 = explode(' - ', $title);
         $exploded2 = explode(' ', $exploded1[0]);
         $shortened .= $exploded2[0];
         $next = 1;
         while(strlen($shortened.' '.$exploded2[$next].' - '.$exploded1[1]) < 40)
         {
            $shortened .= ' '.$exploded2[$next];
            $next++;
         }
         $shortened .= '... - '.$exploded1[1];
      }
      else
      {
         $exploded = explode(' ', $title);
         $shortened .= $exploded[0];
         $next = 1;
         while(strlen($shortened.' '.$exploded[$next]) < 40)
         {
            $shortened .= ' '.$exploded[$next];
            $next++;
         }
         $shortened .= '...';
      }
      return $shortened;
   }
   
   /*
   * secure() processes an input string $text in order to prevent security issues such as 
   * injection of JavaScript code.
   *
   * @param string $text  The input string
   * @return string       The same string processed to prevent the use of HTML or JavaScript
   */
   
   public static function secure($text)
   {
      return htmlspecialchars(preg_replace('(javascript\s{0,}:)iUs','',$text));
   }
   
   /*
   * Tests a field from a row extracted from the database that is either "yes" or "no".
   *
   * @param string $yesOrNo  A string (extracted from the database) saying "yes" or "no"
   * @param bool             True if the string equals "yes"
   */
   
   public static function check($yesOrNo)
   {
      return $yesOrNo === 'yes';
   }
   
   /*
   * Returns the UNIX timestamp of the SQL server. It is preferred to the PHP function time() 
   * because what it returns can vary wildly under some hosting solutions.
   *
   * @return number  The UNIX timestamp of the SQL server
   */
   
   public static function SQLServerTime()
   {
      if(self::$bufferedTime != 0)
         return self::$bufferedTime;
      
      $time = Database::hardRead("SELECT UNIX_TIMESTAMP() AS time", true);
      self::$bufferedTime = $time['time'];
      return $time['time'];
   }
   
   /*
   * Converts a UNIX timestamp into the corresponding DATETIME format for SQL queries.
   *
   * @param integer $t  A UNIX timestamp
   * @return string     The same date in DATETIME format
   */
   
   public static function toDatetime($t)
   {
      return date('Y-m-d H:i:s', $t);
   }
   
   /*
   * Performs the reverse operation of toDatetime().
   *
   * @param string $dbTime  A date in DATETIME format
   * @return integer        The same date as a UNIX timestamp
   */
   
   public static function toTimestamp($dbTime)
   {
      $arr = array('y' => substr($dbTime, 0, 4),
      'm' => substr($dbTime, 5, 2),
      'd' => substr($dbTime, 8, 2),
      'h' => substr($dbTime, 11, 2),
      'min' => substr($dbTime, 14, 2),
      's' => substr($dbTime, 17, 2));
      
      return mktime($arr['h'], $arr['min'], $arr['s'], $arr['m'], $arr['d'], $arr['y']);
   }
   
   /*
   * Formats the date as a string. It removes the year when it's the current one.
   * 
   * @param string $dbTime  A date in DATETIME format
   * @return string         The formatted date
   */

   public static function printDate($dbTime)
   {
      $curTime = Utils::SQLServerTime();
      $arr = array('y' => substr($dbTime, 0, 4),
      'm' => substr($dbTime, 5, 2),
      'd' => substr($dbTime, 8, 2),
      'h' => substr($dbTime, 11, 2),
      'min' => substr($dbTime, 14, 2),
      's' => substr($dbTime, 17, 2));
      
      $res = $arr['d'].'/'.$arr['m'];
      if(date('Y', $curTime) !== $arr['y'])
         $res .= '/'.$arr['y'];
      $res .= ' à '.$arr['h'].':'.$arr['min'].':'.$arr['s'];
      return $res;
   }
   
   /*
   * In a sequence of arrays with dates, removes the seconds from arrays which are unique up to 
   * the minutes (or further). Consecutives arrays where only seconds differ keep the seconds part.
   *
   * @param mixed[] $arrays  The sequence of arrays (2D array, each array has the "date" key)
   * @return mixed[]         The updated arrays;
   */
   
   public static function removeSeconds($arrays)
   {
      $prev = '';
      $prevHasSeconds = false;
      for($i = 0; $i < count($arrays) - 1; $i++)
      {
         $cur = $arrays[$i + 1]['date'];
         if($prev === '')
            $prev = $arrays[$i]['date'];
         
         $exploded1 = explode(':', $cur);
         $exploded2 = explode(':', $prev);
         if($exploded1[0] !== $exploded2[0] || $exploded1[1] !== $exploded2[1])
         {
            if(!$prevHasSeconds)
               $arrays[$i]['date'] = $exploded2[0].':'.$exploded2[1];
            else
               $prevHasSeconds = false;
            if($i == (count($arrays) - 2))
               $arrays[$i + 1]['date'] = $exploded1[0].':'.$exploded1[1];
         }
         else
            $prevHasSeconds = true;
         
         $prev = $cur;
      }
      return $arrays;
   }
}

/*
* ==============
* TemplateEngine
* ==============
*
* This final class implements a custom template engine (templates tailored for it end in 
* .ctpl, for Custom TemPLate) used to handle the various components of the website in a generic 
* fashion, using blocks (starting and ending with curly braces) to signal the parts that should 
* slightly changed from one execution to another. To see what kinds of blocks are available, you 
* can either check the documentation (if available) or go through the private process() method.
*/

class TemplateEngine
{
   /*
   * Gets a template as a string on the basis of its location compared to the root directory.
   *
   * @param string $path  The path to the template (relative to the root directory)
   * @return string       The template as a string or an empty string in case of error
   */
   
   private static function get($path)
   {
      $finalPath = PathHandler::WWW_PATH().$path;
      
      if(strtolower(substr($finalPath, -5)) !== '.ctpl' || !file_exists($finalPath))
         return '';
      
      $content = file_get_contents($finalPath);
      if($content != FALSE)
         return $content;
      return '';
   }
   
   /*
   * Processes a template to replace the parts contained inside brackets ({}) by their values 
   * inside the array $data (either a single variable, either an index in a list of choices) or by 
   * an empty string if no data is provided. Such data is given in a 2D array to allow parsing of 
   * a single template into multiple outputs, rather than re-doing the entire parsing multiple 
   * times.
   *
   * If a value is missing in $data or if $data is not a 2D array, the policy is to return an 
   * array containing the line where the error stands and the content of the brackets that induced 
   * the error.
   *
   * @param string $template  The template as a string
   * @param mixed $data[][]   A 2D array where each line contains the values that should be used 
   *                          to parse the {} blocks in the template; if not provided, all blocks 
   *                          are replaced by an empty string
   * @return mixed            The final views, or an array [[line,misused block]] in case of error 
   *                          (a 2D array is used, because successful output is either a single 
   *                          array either a single string)
   */
   
   private static function process($template, $data = NULL)
   {
      if($data != NULL && (!is_array($data) || !is_array($data[0])))
      {
         return array(array(0, 'The data to parse must be provided as a 2D array'));
      }
      $labels = NULL;
      $nbOutputs = 1;
         
      if($data != NULL)
      {
         $nbOutputs = count($data);
         $labels = array_keys($data[0]);
         if($labels === range(0, count($data[0]) - 1))
         {
            return array(array(0, 'The input arrays must be associative'));
         }
      }
      
      $remaining = $template;
      $parsed = array();
      for($i = 0; $i < $nbOutputs; $i++)
         array_push($parsed, '');
      $length = strlen($remaining);
      
      $insideBlock = false;
      $skipNewLines = false;
      $curBlock = '';
      
      // Goes through the template linearly, spots the blocks inside brackets ({})
      $posNextBlock = strpos($remaining, '{');
      while($posNextBlock !== FALSE)
      {
         $posClosing = strpos($remaining, '}', $posNextBlock);
         if($posClosing === FALSE)
            return array(0, 'Parsing error: mismatching accolades');
         $curBlock = substr($remaining, $posNextBlock + 1, $posClosing - $posNextBlock - 1);
         $parsedSingle = substr($remaining, 0, $posNextBlock);
         for($i = 0; $i < $nbOutputs; $i++)
            $parsed[$i] .= $parsedSingle;
         $remaining = substr($remaining, $posClosing + 1);
         
         $curBlock = str_replace("|\r\n", '|', $curBlock);
         $curBlock = str_replace("|\n", '|', $curBlock);
         
         // No data at all (can be intentional): skip to next block
         if($data == NULL)
         {
            $curBlock = '';
            $posNextBlock = strpos($remaining, '{');
            continue;
         }
         
         // End of a block: parses it
         if(substr($curBlock, 0, 1) == '$')
         {
            $label = substr($curBlock, 1);
            if(in_array($label, $labels))
            {
               for($i = 0; $i < $nbOutputs; $i++)
                  $parsed[$i] .= $data[$i][$label];
            }
            else
            {
               $eMsg = 'Failed to parse block {'.$curBlock.'}';
               return array(array(substr_count($parsed[0], "\n"), $eMsg));
            }
         }
         // List block: particular format, see doc.
         else if(substr($curBlock, 0, 5) === 'list:')
         {
            // Extraction of the label, the items of the list and the surrounding pieces of HTML
            $delimiter = strpos($curBlock, '[');
            if($delimiter === FALSE)
            {
               $eMsg = 'Erroneous syntax in list block {'.$curBlock.'}';
               return array(array(substr_count($parsed[0], "\n"), $eMsg));
            }
            $label = substr($curBlock, 5, $delimiter - 5);
            $firstSplit = explode('||', substr($curBlock, $delimiter + 1));
            if(count($firstSplit) != 2)
            {
               $eMsg = 'Erroneous syntax in list '.$label.', missing "||"';
               return array(array(substr_count($parsed[0], "\n"), $eMsg));
            }
            $itemsToParse = explode('|', $firstSplit[1]);
            $items = array();
            for($i = 0; $i < count($itemsToParse); $i++)
            {
               $split = explode(' & ', $itemsToParse[$i]);
               if (count($split) != 2)
               {
                  $eMsg = 'Erroneous syntax in list '.$label.', missing " & " for item labels';
                  return array(array(substr_count($parsed[0], "\n"), $eMsg));
               }
               $items[$split[0]] = $split[1];
            }
            
            $surroundings = explode('|', substr($firstSplit[0], 0, -1));
            if(count($surroundings) != 3)
            {
               $eMsg = 'Erroneous syntax in list '.$label.', bad format for list surroundings';
               return array(array(substr_count($parsed[0], "\n"), $eMsg));
            }
            
            // Parses the data provided and displays accordingly
            $keys = array_keys($items);
            
            if(!in_array($label, $labels))
            {
               $eMsg = 'No data is provided for list '.$label;
               return array(array(substr_count($parsed[0], "\n"), $eMsg));
            }
            
            for($i = 0; $i < $nbOutputs; $i++)
            {
               $selected = $data[$i][$label];
               if($selected != '')
               {
                  if(strpos($selected, '|') !== FALSE)
                  {
                     $parsed[$i] .= $surroundings[1]."\n";
                     $selectedItems = explode('|', $selected);
                     for($j = 0; $j < count($selectedItems); $j++)
                     {
                        if(!in_array($selectedItems[$j], $keys))
                        {
                           $eMsg = 'Item '.$selectedItems[$j].' (parsing n°'.($i + 1).') does not exist in list '.$label;
                           return array(array(substr_count($parsed[$i], "\n"), $eMsg));
                        }
                        $parsed[$i] .= '-'.$items[$selectedItems[$j]]."<br/>\n";
                     }
                     $parsed[$i] .= $surroundings[2]."\n";
                  }
                  else
                  {
                     if(!in_array($selected, $keys))
                     {
                        $eMsg = 'Item '.$selected.' (parsing n°'.($i + 1).') does not exist in list '.$label;
                        return array(array(substr_count($parsed[$i], "\n"), $eMsg));
                     }
                     $parsed[$i] .= $surroundings[0]."\n";
                     $parsed[$i] .= $items[$selected]."<br/>\n";
                     $parsed[$i] .= $surroundings[2]."\n";
                  }
               }
            }
         }
         // Switch block: similar to list, but at most one item at a time
         else if(substr($curBlock, 0, 7) === 'switch:')
         {
            $delimiter = strpos($curBlock, '||');
            if($delimiter === FALSE)
            {
               $eMsg = 'Erroneous syntax in switch block {'.$curBlock.'}';
               return array(array(substr_count($parsed[0], "\n"), $eMsg));
            }
            $label = substr($curBlock, 7, $delimiter - 7);
            $itemsToParse = explode('|', substr($curBlock, $delimiter + 2));
            $items = array();
            for($i = 0; $i < count($itemsToParse); $i++)
            {
               $split = explode(' & ', $itemsToParse[$i]);
               if (count($split) != 2)
               {
                  $eMsg = 'Erroneous syntax in switch '.$label.', missing " & " for item labels';
                  return array(array(substr_count($parsed[0], "\n"), $eMsg));
               }
               $items[$split[0]] = $split[1];
            }
            
            $keys = array_keys($items);
            
            if(!in_array($label, $labels))
            {
               $eMsg = 'No data is provided for switch block '.$label;
               return array(array(substr_count($parsed[0], "\n"), $eMsg));
            }
            
            /*
            * Parses the input data for that block if it is not a NULL string. The format is: 
            * label or label||value0|value1|...; in the second cases, substrings [0], [1]... 
            * will be replaced by value0, value1... respectively).
            */
            
            for($i = 0; $i < $nbOutputs; $i++)
            {
               $selectedLabel = $data[$i][$label];
               if($selectedLabel != '')
               {
                  $values = NULL;
                  if(strpos($selectedLabel, '||') != FALSE)
                  {
                     $exploded = explode('||', $selectedLabel);
                     $selectedLabel = $exploded[0];
                     $values = explode('|', $exploded[1]);
                  }
                  if(!in_array($selectedLabel, $keys))
                  {
                     $eMsg = 'Item '.$selectedLabel.' (parsing n°'.($i + 1).') does not exist in switch block '.$label;
                     return array(array(substr_count($parsed[$i], "\n"), $eMsg));
                  }
                  $item = $items[$selectedLabel];
                  if($values != NULL)
                  {
                     for($j = 0; $j < count($values); $j++)
                     {
                        if($values[$j] === 'NULL')
                           $item = str_replace('['.$j.']', '', $item);
                        else
                           $item = str_replace('['.$j.']', $values[$j], $item);
                     }
                  }
                  $parsed[$i] .= $item."\n";
               }
            }
         }
         // Select blocks (simple or multiple); select items are provided as input
         else if(substr($curBlock, 0, 7) === 'select:' || substr($curBlock, 0, 12) === 'multiselect:')
         {
            $multiselect = false;
            if(substr($curBlock, 0, 12) === 'multiselect:')
               $multiselect = true;
         
            $label = '';
            if($multiselect)
               $label = substr($curBlock, 12);
            else
               $label = substr($curBlock, 7);
            
            for($i = 0; $i < $nbOutputs; $i++)
            {
               $items = $data[$i][$label];
            
               $values = '';
               if(strpos($items, '||') != FALSE)
               {
                  $exploded = explode('||', $items);
                  $values = $exploded[0];
                  $items = $exploded[1];
               }
               $itemsArr = explode('|', $items);
               $valuesArr = explode('|', $values);
               
               if($multiselect)
                  $parsed[$i] .= "<select id=\"".$label."\" name=\"".$label."[]\" multiple>\n";
               else
                  $parsed[$i] .= "<select name=\"".$label."\">\n";
               for($j = 0; $j < count($itemsArr); $j++)
               {
                  if(strpos($itemsArr[$j], ',') != FALSE)
                  {
                     $pair = explode(',', $itemsArr[$j], 2);
                     if(in_array($pair[0], $valuesArr))
                        $parsed[$i] .= '<option value="'.$pair[0].'" selected="selected">'.$pair[1].'</option>'."\n";
                     else
                        $parsed[$i] .= '<option value="'.$pair[0].'">'.$pair[1].'</option>'."\n";
                  }
                  else
                  {
                     if(in_array($itemsArr[$j], $valuesArr))
                        $parsed[$i] .= '<option value="'.$itemsArr[$j].'" selected="selected">'.$itemsArr[$j].'</option>'."\n";
                     else
                        $parsed[$i] .= '<option value="'.$itemsArr[$j].'">'.$itemsArr[$j].'</option>'."\n";
                  }
               }
               $parsed[$i] .= "</select>\n";
            }
         }
         // Pages block: generates list of pages; strict format
         else if(substr($curBlock, 0, 6) === 'pages:')
         {
            $delimiter = strpos($curBlock, '||');
            if($delimiter === FALSE)
            {
               $eMsg = 'Erroneous syntax in pages block {'.$curBlock.'}';
               return array(array(substr_count($parsed[0], "\n"), $eMsg));
            }
            $label = substr($curBlock, 6, $delimiter - 6);
            $pagesElements = explode('|', substr($curBlock, $delimiter + 2));
            if(count($pagesElements) != 5)
            {
               $eMsg = 'Erroneous syntax in pages block '.$label.': needs 5 parameters';
               return array(array(substr_count($parsed[0], "\n"), $eMsg));
            }
            
            // Checks format of HTML surroundings and parses them
            $surroundings1 = NULL;
            $surroundings2 = NULL;
            if(substr_count($pagesElements[2], '[]') != 1 && $pagesElements[2] !== 'none')
            {
               $eMsg = 'Erroneous syntax in pages block '.$label.': [2] must contain placeholder [] only once or "none"';
               return array(array(substr_count($parsed[0], "\n"), $eMsg));
            }
            else if($pagesElements[2] !== 'none')
               $surroundings1 = explode('[]', $pagesElements[2]);
            
            if(substr_count($pagesElements[3], '[]') != 1 && $pagesElements[3] !== 'none')
            {
               $eMsg = 'Erroneous syntax in pages block '.$label.': [3] must contain placeholder [] only once or "none"';
               return array(array(substr_count($parsed[0], "\n"), $eMsg));
            }
            else if($pagesElements[3] !== 'none')
               $surroundings2 = explode('[]', $pagesElements[3]);
            
            for($i = 0; $i < $nbOutputs; $i++)
            {
               // Skips if input is empty (can be intentional)
               if($data[$i][$label] === '')
               {
                  $curBlock = '';
                  $posNextBlock = strpos($remaining, '{');
                  continue;
               }
               
               // Checks arguments (strict format: perPage|nbItems|curPage|linkTemplate) and parses them
               if(!in_array($label, $labels))
               {
                  $eMsg = 'No data is provided for pages block '.$label;
                  return array(array(substr_count($parsed[0], "\n"), $eMsg));
               }
               $pagesInput = explode('|', $data[$i][$label]);
               if(count($pagesInput) != 4)
               {
                  $eMsg = 'Wrong usage of pages block '.$label.', please double check arguments';
                  return array(array(substr_count($parsed[0], "\n"), $eMsg));
               }
               $perPage = intval($pagesInput[0]);
               $nbItems = intval($pagesInput[1]);
               $curPage = intval($pagesInput[2]);
               $linkTemplate = explode('[]', $pagesInput[3]);
               if(count($linkTemplate) != 2)
               {
                  $eMsg = 'Wrong usage of pages block '.$label.', link template is not properly formatted';
                  return array(array(substr_count($parsed[0], "\n"), $eMsg));
               }
               
               // Moves on if there is not enough content to have multiple pages
               if($nbItems <= $perPage)
               {
                  $curBlock = '';
                  $posNextBlock = strpos($remaining, '{');
                  continue;
               }
               
               // Otherwise, displays the pages
               $parsed[$i] .= $pagesElements[0];
               $nbPages = ceil($nbItems / $perPage);
               $hasSkipped = false;
               for($j = 1; $j <= $nbPages; $j++)
               {
                  if($j <= 5 || $j >= ($nbPages - 5) || ($j >= ($curPage - 5) && $j <= ($curPage + 5)))
                  {
                     if($j == $curPage)
                     {
                        if($surroundings1 != NULL)
                           $parsed[$i] .= $surroundings1[0].$j.$surroundings1[1].' ';
                        else
                           $parsed[$i] .= $j.' ';
                     }
                     else
                     {
                        $link = '<a href="'.$linkTemplate[0].$j.$linkTemplate[1].'">'.$j.'</a>';
                        if($surroundings2 != NULL)
                           $parsed[$i] .= $surroundings2[0].$link.$surroundings2[1].' ';
                        else
                           $parsed[$i] .= $link.' ';
                     }
                     $hasSkipped = false;
                  }
                  // "..." (in "Pages: 1 2 3 4 5 ... 14 15 16 17 18")
                  else if(!$hasSkipped)
                  {
                     $parsed[$i] .= $pagesElements[5].' ';
                     $hasSkipped = true;
                  }
               }
               if($pagesElements[1] !== 'none')
                  $parsed[$i] .= $pagesElements[1];
            }
         }
         // Advanced paging system for topics
         else if(substr($curBlock, 0, 11) === 'navigation:')
         {
            $label = substr($curBlock, 11);
            for($i = 0; $i < $nbOutputs; $i++)
            {
               // Checks arguments (strict format: perPage|nbItems|curPage|linkTemplate) and parses them
               if(!in_array($label, $labels))
               {
                  $eMsg = 'No data is provided for navigation block '.$label;
                  return array(array(substr_count($parsed[0], "\n"), $eMsg));
               }
               
               $pagesInput = explode('|', $data[$i][$label]);
               if(count($pagesInput) < 5 || count($pagesInput) > 7)
               {
                  $eMsg = 'Wrong usage of navigation block '.$label.', please double check arguments';
                  return array(array(substr_count($parsed[0], "\n"), $eMsg));
               }
               
               $perPage = intval($pagesInput[0]);
               $nbItems = intval($pagesInput[1]);
               $curPage = intval($pagesInput[2]);
               $linkTemplate = explode('[]', $pagesInput[3]);
               $getterScript = $pagesInput[4];
               $refreshScript = '';
               $allSeenScript = '';
               if(count($pagesInput) >= 6)
                  $refreshScript = $pagesInput[5];
               if(count($pagesInput) == 7)
                  $allSeenScript = $pagesInput[6];
               
               if(count($linkTemplate) != 2)
               {
                  $eMsg = 'Wrong usage of navigation block '.$label.', link template is not properly formatted';
                  return array(array(substr_count($parsed[0], "\n"), $eMsg));
               }
               
               // Shortened code if there is not enough content to have multiple pages
               if($nbItems <= $perPage)
               {
                  // Hidden page list; will shows up if automatic refresh is activated
                  $parsed[$i] .= '<p class="pagesNav" data-per-page="'.$perPage.'" data-getter="'.$getterScript.'" ';
                  if(strlen($refreshScript) > 0)
                     $parsed[$i] .= 'data-refresh="'.$refreshScript.'" ';
                  if(strlen($allSeenScript) > 0)
                     $parsed[$i] .= 'data-all-seen="'.$allSeenScript.'" ';
                  $parsed[$i] .= 'data-static-link="'.$pagesInput[3].'" style="display: none;">';
                  $parsed[$i] .= '<span class="backBlack">Pages :</span> </p>';
               
                  $curBlock = '';
                  $posNextBlock = strpos($remaining, '{');
                  continue;
               }
               
               // Otherwise, displays the pages
               $parsed[$i] .= '<p class="pagesNav" data-per-page="'.$perPage.'" data-getter="'.$getterScript.'" ';
               if(strlen($refreshScript) > 0)
                  $parsed[$i] .= 'data-refresh="'.$refreshScript.'" ';
               if(strlen($allSeenScript) > 0)
                  $parsed[$i] .= 'data-all-seen="'.$allSeenScript.'" ';
               $parsed[$i] .= 'data-static-link="'.$pagesInput[3].'"><span class="backBlack">Pages :</span> ';
               $nbPages = ceil($nbItems / $perPage);
               $hideMiddle = false;
               if($nbPages > 15)
                  $hideMiddle = true;
               for($j = 1; $j <= $nbPages; $j++)
               {
                  // Hidden pages in the middle of the list
                  if($hideMiddle)
                  {
                     if($j == 6)
                        $parsed[$i] .= '<span class="hiddenPages">';
                     else if($j == $nbPages - 4)
                        $parsed[$i] .= '</span><span class="unhidePages">...</span> ';
                  }
               
                  if($j == $curPage)
                  {
                     $parsed[$i] .= '<span class="pageLinkSelected" data-page="'.$j.'">'.$j.'</span> ';
                  }
                  else
                  {
                     $parsed[$i] .= '<span class="pageLink" data-page="'.$j.'">';
                     $parsed[$i] .= '<a href="'.$linkTemplate[0].$j.$linkTemplate[1].'">'.$j.'</a>';
                     $parsed[$i] .= '</span> ';
                  }
               }
               $parsed[$i] .= '</p>';
            }
         }
         // Optional block: single optional item (in HTML) needing only one input (e.g. a link)
         else if(substr($curBlock, 0, 9) === 'optional:')
         {
            $delimiter = strpos($curBlock, '||');
            if($delimiter === FALSE)
            {
               $eMsg = 'Erroneous syntax in optional link block {'.$curBlock.'}';
               return array(array(substr_count($parsed[0], "\n"), $eMsg));
            }
            $label = substr($curBlock, 9, $delimiter - 9);
            $item = substr($curBlock, $delimiter + 2);
            
            if(!in_array($label, $labels))
            {
               $eMsg = 'No data is provided for optional link block '.$label;
               return array(array(substr_count($parsed[0], "\n"), $eMsg));
            }
            
            /*
            * Parses the input data for that block if it is not a NULL string. The block is 
            * replaced its HTML content it contains, where the [] is replaced with the input.
            */
            
            for($i = 0; $i < $nbOutputs; $i++)
            {
               $selectedLabel = $data[$i][$label];
               if($selectedLabel != '')
               {
                  $itemEdited = str_replace('[]', $selectedLabel, $item);
                  $parsed[$i] .= $itemEdited."\n";
               }
            }
         }
         
         $curBlock = '';
         $posNextBlock = strpos($remaining, '{');
      }
      for($i = 0; $i < $nbOutputs; $i++)
         $parsed[$i] .= $remaining;
      
      return $parsed;
   }
   
   /*
   * Checks the return value of process() to ensure the template was successfully processed. 
   * Otherwise, a HTML string detailing the error(s) is returned.
   *
   * @param string $arg  The return value of process()
   * @return string      $arg if there is no error, otherwise a HTML string detailling the error
   */
   
   private static function error($arg)
   {
      if($arg === '')
      {
         $message = '<p><strong>Unexpected error :</strong> missing template. Reports this error 
         to the webmaster as soon as possible.</p>'."\n";
         return $message;
      }
      else if(is_array($arg) && is_array($arg[0]))
      {
         $message = '<p><strong>Unexpected error :</strong> misused template. Reports the 
         following error to the webmaster as soon as possible :<br/>
         <br/>
         Line '.$arg[0][0].': '.$arg[0][1].'</p>'."\n";
         return $message;
      }
      return $arg;
   }
   
   /*
   * Gets and parses a template, and checks if an error occurred. It essentially combines together 
   * the previous methods into a single one that can be called to use a template a single time.
   *
   * @param string $path   The path to the template (relative to the root directory)
   * @param mixed $data[]  An array of values to replace the {} blocks in the template; if not 
   *                       provided, all {} blocks are replaced by an empty string
   * @return string        The produced content or some HTML string explaining what went wrong
   */
   
   public static function parse($path, $data = NULL)
   {
      $tpl = self::get($path);
      if($tpl === '')
         return self::error('');
      
      $as2DArray = NULL;
      if($data != NULL)
      {
         $as2DArray = array();
         array_push($as2DArray, $data);
      }
      
      $output = self::process($tpl, $as2DArray);
      if(is_array($output[0]))
         return self::error($output);
      
      return self::error($output[0]);
   }
   
   /*
   * Fullfills the same tasks as the previous method but for multiple outputs (e.g., parsing 
   * multiple messages in a topic using a same template). This approach avoids entirely parsing 
   * a template multiple times, an operation which would add processing overhead for pages where 
   * multiple items of a same kind are being displayed.
   *
   * @param string $path     The path to the template (relative to the root directory)
   * @param mixed $data[][]  A 2D array of values to replace the {} blocks in the template, each 
   *                         line corresponding to the input for one use of the template
   * @return mixed           The final pieces of content as a linear array (each item matches one 
   *                         use of the template) or some HTML string explaining what went wrong
   */

   public static function parseMultiple($path, $data = NULL)
   {
      $tpl = self::get($path);
      if($tpl === '')
         return self::error('');
      return self::error(self::process($tpl, $data));
   }
   
   /*
   * Parses one output string of the template engine to tell whether it's an error message or a 
   * healthy output.
   *
   * @param string $arg  An output string produced by the template engine
   * @return bool        True if it's an error message, false otherwise
   */
   
   public static function hasFailed($arg)
   {
      if(!is_array($arg) && substr($arg, 11, 16) === 'Unexpected error')
         return true;
      return false;
   }
}

?>
