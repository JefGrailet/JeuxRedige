<?php

/**
 * This file defines a static class to dialog with the database. It fulfills at least two purposes:
 * on the one hand, it highlights in the code when the SQL database is accessed (thanks to the 
 * Database:: prefix), and on the other hand, it acts as a security bottleneck. I.e., if there's 
 * something wrong with the way SQL queries are parsed and executed, one should normally only edit 
 * this particular class and nothing else.
 * 
 * Please note that the "read" and "write" in method names are somewhat in name only: their body  
 * can virtually execute anything. The API is nevertheless designed to provide outputs in the 
 * format preferred by the calling code, as well as to explicitely tell what kind of operation is 
 * being performed.
 */

class Database
{
   private static $pdo = NULL;
   
   /**
    * Initializes the connection to the DB.
    * 
    * @param string $host    The host of the database
    * @param string $dbName  The name of the database
    * @param string $login   The login to connect to the database
    * @param string $pwd     The password to connect to the dabatase
    * @param integer $port   The port to connect to the database (optional); -1 (default) means no 
    *                        specific port needs to be selected
    */
   
   public static function init($host, $dbName, $login, $pwd, $port=-1)
   {  
      try
      {
         $pdo_options[PDO::ATTR_ERRMODE] = PDO::ERRMODE_EXCEPTION;
         
         $DSN = 'mysql:host='.$host.';';
         if(is_string($port) || $port != -1)
            $DSN .= 'port='.strval($port).';';
         $DSN .= 'dbname='.$dbName;
         
         self::$pdo = new PDO($DSN, $login, $pwd);
         self::$pdo->exec("SET CHARACTER SET utf8");
      }
      catch(Exception $e)
      {
         die('Could not connect to the database ('.$e->getMessage().')');
      }
   }
   
   /**
    * hardWrite() executes $query, assumed to perform a write operation in the database (insertion 
    * or update). Such $query does not need to be parsed (hence the "hard").
    *
    * @param string $query  The query to execute
    * @param bool $nbRows   A boolean that can be used to change the return value of this method 
    *                       into the number of rows affected by the query (optional)
    * @return mixed         Number of affected rows if $returnNbRows is true, otherwise NULL in 
    *                       case of success; the error generated by PDO is returned otherwise
    */ 
   
   public static function hardWrite($query, $nbRows = false)
   {
      $queryObject = NULL;
      try
      {
         $queryObject = self::$pdo->query($query);
      }
      catch (PDOException $e)
      {
         return $e->errorInfo;
      }
         
      $returnValue = NULL;
      if($nbRows)
        $returnValue = $queryObject->rowCount();
      $queryObject->closeCursor();
      
      return $returnValue;
   }
   
   /**
    * hardRead() is the equivalent of hardWrite() for reading in the database.
    *
    * @param string $query    The query to execute
    * @param bool $singleRes  A boolean that can be used to return a simple array if the query is 
    *                         guaranteed to return a single row; a 2D array with several rows is 
    *                         returned otherwise (optional)
    * @return mixed           The row(s) matching the query as a 2D or linear array if $singleRes 
    *                         is true in case of success; otherwise, the PDO error is returned
    */
   
   public static function hardRead($query, $singleRes = false)
   {
      $queryObject = NULL;
      try
      {
         $queryObject = self::$pdo->query($query);
      }
      catch (PDOException $e)
      {
         return $e->errorInfo;
      }
      
      if($singleRes)
         $result = $queryObject->fetch(PDO::FETCH_ASSOC);
      else
         $result = $queryObject->fetchAll(PDO::FETCH_ASSOC);
      $queryObject->closeCursor();
      return $result;
   }
   
   /**
    * secureWrite() executes $query, assumed to perform a write operation in the database. It 
    * is essentially a proxy for PDO prepared query mechanism for queries that modify the content 
    * of the database.
    *
    * @param string $query  The query to execute (args are either question marks or identifiers)
    * @param mixed $arg[]   The inputs to parse in the query
    * @param bool $nbRows   A boolean that can be used to change the return value of this method 
    *                       into the number of rows affected by the query, just like hardWrite()
    * @return mixed         Number of affected rows if $returnNbRows is true, otherwise NULL in 
    *                       case of success; if something goes wrong, the PDO error is returned
    */
   
   public static function secureWrite($query, $arg, $nbRows = false)
   {
      $queryObject = NULL;
      try
      {
        $queryObject = self::$pdo->prepare($query);
        $queryObject->execute($arg);
      }
      catch (PDOException $e)
      {
         return $e->errorInfo;
      }
      
      $returnValue = NULL;
      if($nbRows)
        $returnValue = $queryObject->rowCount();
      
      $queryObject->closeCursor();
      return $returnValue;
   }
   
   /**
    * secureRead() is the equivalent of secureWrite() for reading in the database.
    *
    * @param string $query    The query to execute (args are either question marks or identifiers)
    * @param mixed $arg[]     The inputs to parse in the query
    * @param bool $singleRes  A boolean that can be used to return a simple array if the query is 
    *                         guaranteed to return a single row (2D array is returned otherwise)
    * @return mixed           The row(s) matching the query as a 2D or linear array if $singleRes 
    *                         is true; the PDO error is returned in case of problem
    */
   
   public static function secureRead($query, $arg, $singleRes = false)
   {
      $queryObject = NULL;
      try
      {
         $queryObject = self::$pdo->prepare($query);
         $queryObject->execute($arg);
      }
      catch (PDOException $e)
      {
         return $e->errorInfo;
      }
      
      if($singleRes)
         $result = $queryObject->fetch(PDO::FETCH_ASSOC);
      else
         $result = $queryObject->fetchAll(PDO::FETCH_ASSOC);
      $queryObject->closeCursor();
      return $result;
   }
   
   /**
    * newId() returns the ID of the last row inserted in the database with PDO.
    *
    * @return number  The ID of the last inserted row (self::$pdo->lastInsertId())
    */
   
   public static function newId()
   {
      return self::$pdo->lastInsertId();
   }
   
   /*
    * beginTransaction(), commit() and rollback() are just aliases for the PDO methods of the same 
    * name. The purpose is to avoid using "global $pdo;" in functions/methods involving 
    * transactions and to explicitely reference this static class (for clarity).
    */
   
   public static function beginTransaction() { self::$pdo->beginTransaction(); }
   public static function commit() { self::$pdo->commit(); }
   public static function rollback() { self::$pdo->rollback(); }
   
   /**
    * Alias for the prepare() PDO method. The query object is returned to ensure the $pdo variable 
    * stays encapsulated and unreachable from outside.
    *
    * @param string $query  The SQL query to prepare
    * @return PDOStatement  The PDO query object
    */
   
   public static function prepare($query)
   {
      return self::$pdo->prepare($query);
   }
}
